import sqlite3
import json
import re
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Tuple
import smtplib
from email.mime.text import MimeText
from email.mime.multipart import MimeMultipart
from dataclasses import dataclass, asdict
import hashlib
import schedule
import time
import threading
from pathlib import Path
import logging

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class KeywordSubscription:
    """Classe pour repr√©senter un abonnement"""
    id: Optional[int]
    user_email: str
    keywords: List[str]
    sentiment_filter: Optional[str]  # 'positive', 'negative', 'neutral', None
    sources_filter: Optional[List[str]]
    frequency: str  # 'real_time', 'hourly', 'daily', 'weekly'
    active: bool
    created_at: str
    last_notification: Optional[str]
    min_confidence: float = 0.0

class KeywordSubscriptionManager:
    def __init__(self, db_path: str = "subscriptions.db"):
        """
        Initialise le gestionnaire d'abonnements
        
        Args:
            db_path (str): Chemin vers la base de donn√©es SQLite
        """
        self.db_path = db_path
        self.init_database()
        
        # Configuration email (√† personnaliser)
        self.smtp_config = {
            'server': 'smtp.gmail.com',
            'port': 587,
            'username': '',  # √Ä configurer
            'password': '',  # √Ä configurer (utiliser App Password pour Gmail)
            'from_email': ''  # √Ä configurer
        }
        
        # Historique des articles d√©j√† envoy√©s
        self.sent_articles = set()
        
    def init_database(self):
        """Initialise la base de donn√©es SQLite"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Table des abonnements
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS subscriptions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_email TEXT NOT NULL,
                keywords TEXT NOT NULL,
                sentiment_filter TEXT,
                sources_filter TEXT,
                frequency TEXT NOT NULL,
                active BOOLEAN DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                last_notification TIMESTAMP,
                min_confidence REAL DEFAULT 0.0
            )
        ''')
        
        # Table des notifications envoy√©es
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS notification_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                subscription_id INTEGER,
                article_hash TEXT NOT NULL,
                sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (subscription_id) REFERENCES subscriptions (id)
            )
        ''')
        
        # Index pour optimiser les requ√™tes
        cursor.execute('''
            CREATE INDEX IF NOT EXISTS idx_keywords 
            ON subscriptions (keywords)
        ''')
        cursor.execute('''
            CREATE INDEX IF NOT EXISTS idx_article_hash 
            ON notification_history (article_hash)
        ''')
        
        conn.commit()
        conn.close()
        logger.info("Base de donn√©es initialis√©e")
    
    def configure_email(self, smtp_server: str, port: int, username: str, 
                       password: str, from_email: str):
        """
        Configure les param√®tres email
        
        Args:
            smtp_server (str): Serveur SMTP
            port (int): Port SMTP
            username (str): Nom d'utilisateur
            password (str): Mot de passe (App Password recommand√©)
            from_email (str): Email exp√©diteur
        """
        self.smtp_config.update({
            'server': smtp_server,
            'port': port,
            'username': username,
            'password': password,
            'from_email': from_email
        })
        logger.info("Configuration email mise √† jour")
    
    def create_subscription(self, user_email: str, keywords: List[str], 
                          sentiment_filter: Optional[str] = None,
                          sources_filter: Optional[List[str]] = None,
                          frequency: str = 'daily',
                          min_confidence: float = 0.0) -> int:
        """
        Cr√©e un nouvel abonnement
        
        Args:
            user_email (str): Email de l'utilisateur
            keywords (List[str]): Liste des mots-cl√©s
            sentiment_filter (str, optional): Filtre de sentiment
            sources_filter (List[str], optional): Filtre de sources
            frequency (str): Fr√©quence des notifications
            min_confidence (float): Confiance minimale requise
            
        Returns:
            int: ID de l'abonnement cr√©√©
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        keywords_json = json.dumps(keywords, ensure_ascii=False)
        sources_json = json.dumps(sources_filter) if sources_filter else None
        
        cursor.execute('''
            INSERT INTO subscriptions 
            (user_email, keywords, sentiment_filter, sources_filter, 
             frequency, min_confidence)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (user_email, keywords_json, sentiment_filter, sources_json, 
              frequency, min_confidence))
        
        subscription_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        logger.info(f"Abonnement cr√©√©: ID {subscription_id} pour {user_email}")
        return subscription_id
    
    def get_subscriptions(self, active_only: bool = True) -> List[KeywordSubscription]:
        """
        R√©cup√®re la liste des abonnements
        
        Args:
            active_only (bool): Ne r√©cup√©rer que les abonnements actifs
            
        Returns:
            List[KeywordSubscription]: Liste des abonnements
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        query = "SELECT * FROM subscriptions"
        if active_only:
            query += " WHERE active = 1"
        
        cursor.execute(query)
        rows = cursor.fetchall()
        conn.close()
        
        subscriptions = []
        for row in rows:
            subscription = KeywordSubscription(
                id=row[0],
                user_email=row[1],
                keywords=json.loads(row[2]),
                sentiment_filter=row[3],
                sources_filter=json.loads(row[4]) if row[4] else None,
                frequency=row[5],
                active=bool(row[6]),
                created_at=row[7],
                last_notification=row[8],
                min_confidence=row[9] if len(row) > 9 else 0.0
            )
            subscriptions.append(subscription)
        
        return subscriptions
    
    def update_subscription(self, subscription_id: int, **kwargs):
        """
        Met √† jour un abonnement
        
        Args:
            subscription_id (int): ID de l'abonnement
            **kwargs: Champs √† mettre √† jour
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Construire la requ√™te dynamiquement
        set_clauses = []
        values = []
        
        for field, value in kwargs.items():
            if field in ['keywords', 'sources_filter'] and value is not None:
                value = json.dumps(value, ensure_ascii=False)
            set_clauses.append(f"{field} = ?")
            values.append(value)
        
        values.append(subscription_id)
        
        query = f"UPDATE subscriptions SET {', '.join(set_clauses)} WHERE id = ?"
        cursor.execute(query, values)
        conn.commit()
        conn.close()
        
        logger.info(f"Abonnement {subscription_id} mis √† jour")
    
    def delete_subscription(self, subscription_id: int):
        """
        Supprime un abonnement
        
        Args:
            subscription_id (int): ID de l'abonnement √† supprimer
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("DELETE FROM subscriptions WHERE id = ?", (subscription_id,))
        cursor.execute("DELETE FROM notification_history WHERE subscription_id = ?", 
                      (subscription_id,))
        
        conn.commit()
        conn.close()
        
        logger.info(f"Abonnement {subscription_id} supprim√©")
    
    def match_keywords(self, text: str, keywords: List[str]) -> Tuple[bool, List[str]]:
        """
        V√©rifie si le texte contient les mots-cl√©s
        
        Args:
            text (str): Texte √† analyser
            keywords (List[str]): Liste des mots-cl√©s
            
        Returns:
            Tuple[bool, List[str]]: (Match trouv√©, mots-cl√©s trouv√©s)
        """
        text_lower = text.lower()
        found_keywords = []
        
        for keyword in keywords:
            # Support des expressions r√©guli√®res simples
            if '*' in keyword or '?' in keyword:
                # Convertir wildcard en regex
                pattern = keyword.replace('*', '.*').replace('?', '.')
                if re.search(pattern, text_lower, re.IGNORECASE):
                    found_keywords.append(keyword)
            else:
                # Recherche simple
                if keyword.lower() in text_lower:
                    found_keywords.append(keyword)
        
        return len(found_keywords) > 0, found_keywords
    
    def filter_articles_by_subscription(self, articles: List[Dict], 
                                      subscription: KeywordSubscription) -> List[Dict]:
        """
        Filtre les articles selon les crit√®res d'un abonnement
        
        Args:
            articles (List[Dict]): Liste des articles
            subscription (KeywordSubscription): Abonnement
            
        Returns:
            List[Dict]: Articles filtr√©s
        """
        filtered_articles = []
        
        for article in articles:
            # Texte complet pour la recherche
            full_text = f"{article.get('title', '')} {article.get('description', '')}"
            
            # V√©rification des mots-cl√©s
            keyword_match, found_keywords = self.match_keywords(full_text, subscription.keywords)
            if not keyword_match:
                continue
            
            # Filtre de sentiment
            if subscription.sentiment_filter:
                article_sentiment = article.get('consensus_sentiment', 'neutral')
                if article_sentiment != subscription.sentiment_filter:
                    continue
            
            # Filtre de confiance
            confidence = article.get('confidence_score', 0.0)
            if confidence < subscription.min_confidence:
                continue
            
            # Filtre de sources
            if subscription.sources_filter:
                article_source = article.get('source', '')
                if article_source not in subscription.sources_filter:
                    continue
            
            # Ajouter les mots-cl√©s trouv√©s √† l'article
            article_copy = article.copy()
            article_copy['matched_keywords'] = found_keywords
            filtered_articles.append(article_copy)
        
        return filtered_articles
    
    def generate_article_hash(self, article: Dict) -> str:
        """
        G√©n√®re un hash unique pour un article
        
        Args:
            article (Dict): Article
            
        Returns:
            str: Hash de l'article
        """
        content = f"{article.get('title', '')}{article.get('url', '')}"
        return hashlib.md5(content.encode()).hexdigest()
    
    def is_article_already_sent(self, subscription_id: int, article_hash: str) -> bool:
        """
        V√©rifie si un article a d√©j√† √©t√© envoy√©
        
        Args:
            subscription_id (int): ID de l'abonnement
            article_hash (str): Hash de l'article
            
        Returns:
            bool: True si d√©j√† envoy√©
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT COUNT(*) FROM notification_history 
            WHERE subscription_id = ? AND article_hash = ?
        ''', (subscription_id, article_hash))
        
        count = cursor.fetchone()[0]
        conn.close()
        
        return count > 0
    
    def mark_article_as_sent(self, subscription_id: int, article_hash: str):
        """
        Marque un article comme envoy√©
        
        Args:
            subscription_id (int): ID de l'abonnement
            article_hash (str): Hash de l'article
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO notification_history (subscription_id, article_hash)
            VALUES (?, ?)
        ''', (subscription_id, article_hash))
        
        conn.commit()
        conn.close()
    
    def create_email_content(self, articles: List[Dict], subscription: KeywordSubscription) -> str:
        """
        Cr√©e le contenu HTML de l'email
        
        Args:
            articles (List[Dict]): Articles √† inclure
            subscription (KeywordSubscription): Abonnement
            
        Returns:
            str: Contenu HTML
        """
        html_content = f"""
        <html>
        <head>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background-color: #f8f9fa; padding: 20px; border-radius: 5px; }}
                .article {{ border: 1px solid #dee2e6; margin: 15px 0; padding: 15px; border-radius: 5px; }}
                .title {{ color: #007bff; font-weight: bold; font-size: 18px; }}
                .meta {{ color: #6c757d; font-size: 12px; margin: 5px 0; }}
                .sentiment {{ padding: 3px 8px; border-radius: 3px; font-size: 11px; }}
                .positive {{ background-color: #d4edda; color: #155724; }}
                .negative {{ background-color: #f8d7da; color: #721c24; }}
                .neutral {{ background-color: #e2e3e5; color: #383d41; }}
                .keywords {{ background-color: #fff3cd; padding: 5px; border-radius: 3px; margin: 5px 0; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h2>üîî Actualit√©s pour vos mots-cl√©s</h2>
                <p><strong>Mots-cl√©s:</strong> {', '.join(subscription.keywords)}</p>
                <p><strong>Nombre d'articles:</strong> {len(articles)}</p>
                <p><strong>Date:</strong> {datetime.now().strftime('%d/%m/%Y %H:%M')}</p>
            </div>
        """
        
        for article in articles:
            sentiment = article.get('consensus_sentiment', 'neutral')
            sentiment_class = sentiment
            sentiment_emoji = {'positive': 'üòä', 'negative': 'üòü', 'neutral': 'üòê'}.get(sentiment, 'üòê')
            
            score = article.get('sentiment_score', 0)
            matched_keywords = article.get('matched_keywords', [])
            
            html_content += f"""
            <div class="article">
                <div class="title">
                    <a href="{article.get('url', '#')}" target="_blank">
                        {article.get('title', 'Sans titre')}
                    </a>
                </div>
                <div class="meta">
                    <strong>Source:</strong> {article.get('source', 'Inconnue')} | 
                    <strong>Date:</strong> {article.get('published_at', 'Non sp√©cifi√©e')}
                </div>
                <div class="meta">
                    <span class="sentiment {sentiment_class}">
                        {sentiment_emoji} {sentiment.title()} (Score: {score:.2f})
                    </span>
                </div>
                {f'<div class="keywords"><strong>Mots-cl√©s trouv√©s:</strong> {", ".join(matched_keywords)}</div>' if matched_keywords else ''}
                <p>{article.get('description', 'Pas de description disponible')[:300]}...</p>
            </div>
            """
        
        html_content += """
            <div class="header" style="margin-top: 30px;">
                <p><small>
                    Vous recevez cet email car vous √™tes abonn√© aux alertes pour ces mots-cl√©s.<br>
                    Pour modifier vos abonnements, contactez l'administrateur.
                </small></p>
            </div>
        </body>
        </html>
        """
        
        return html_content
    
    def send_notification_email(self, subscription: KeywordSubscription, articles: List[Dict]):
        """
        Envoie un email de notification
        
        Args:
            subscription (KeywordSubscription): Abonnement
            articles (List[Dict]): Articles √† envoyer
        """
        if not self.smtp_config['username']:
            logger.warning("Configuration email manquante")
            return
        
        try:
            # Cr√©er le message
            msg = MimeMultipart('alternative')
            msg['Subject'] = f"üîî {len(articles)} nouveaux articles pour vos mots-cl√©s"
            msg['From'] = self.smtp_config['from_email']
            msg['To'] = subscription.user_email
            
            # Contenu HTML
            html_content = self.create_email_content(articles, subscription)
            html_part = MimeText(html_content, 'html', 'utf-8')
            msg.attach(html_part)
            
            # Envoyer l'email
            with smtplib.SMTP(self.smtp_config['server'], self.smtp_config['port']) as server:
                server.starttls()
                server.login(self.smtp_config['username'], self.smtp_config['password'])
                server.send_message(msg)
            
            logger.info(f"Email envoy√© √† {subscription.user_email} ({len(articles)} articles)")
            
            # Marquer les articles comme envoy√©s
            for article in articles:
                article_hash = self.generate_article_hash(article)
                self.mark_article_as_sent(subscription.id, article_hash)
            
            # Mettre √† jour la date de derni√®re notification
            self.update_subscription(subscription.id, 
                                   last_notification=datetime.now().isoformat())
            
        except Exception as e:
            logger.error(f"Erreur lors de l'envoi de l'email √† {subscription.user_email}: {e}")
    
    def process_subscriptions(self, articles: List[Dict]):
        """
        Traite tous les abonnements pour une liste d'articles
        
        Args:
            articles (List[Dict]): Articles analys√©s
        """
        subscriptions = self.get_subscriptions(active_only=True)
        
        if not subscriptions:
            logger.info("Aucun abonnement actif")
            return
        
        logger.info(f"Traitement de {len(subscriptions)} abonnements pour {len(articles)} articles")
        
        for subscription in subscriptions:
            try:
                # Filtrer les articles selon les crit√®res
                filtered_articles = self.filter_articles_by_subscription(articles, subscription)
                
                if not filtered_articles:
                    continue
                
                # Exclure les articles d√©j√† envoy√©s
                new_articles = []
                for article in filtered_articles:
                    article_hash = self.generate_article_hash(article)
                    if not self.is_article_already_sent(subscription.id, article_hash):
                        new_articles.append(article)
                
                if new_articles:
                    logger.info(f"Envoi de {len(new_articles)} nouveaux articles √† {subscription.user_email}")
                    self.send_notification_email(subscription, new_articles)
                
            except Exception as e:
                logger.error(f"Erreur lors du traitement de l'abonnement {subscription.id}: {e}")
    
    def cleanup_old_notifications(self, days_to_keep: int = 30):
        """
        Nettoie l'historique des notifications anciennes
        
        Args:
            days_to_keep (int): Nombre de jours √† conserver
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cutoff_date = datetime.now() - timedelta(days=days_to_keep)
        
        cursor.execute('''
            DELETE FROM notification_history 
            WHERE sent_at < ?
        ''', (cutoff_date.isoformat(),))
        
        deleted_count = cursor.rowcount
        conn.commit()
        conn.close()
        
        logger.info(f"Supprim√© {deleted_count} anciennes notifications")
    
    def get_subscription_stats(self) -> Dict:
        """
        Retourne les statistiques des abonnements
        
        Returns:
            Dict: Statistiques
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Statistiques g√©n√©rales
        cursor.execute("SELECT COUNT(*) FROM subscriptions WHERE active = 1")
        active_subscriptions = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(DISTINCT user_email) FROM subscriptions WHERE active = 1")
        unique_users = cursor.fetchone()[0]
        
        cursor.execute('''
            SELECT frequency, COUNT(*) 
            FROM subscriptions WHERE active = 1 
            GROUP BY frequency
        ''')
        frequency_stats = dict(cursor.fetchall())
        
        cursor.execute('''
            SELECT COUNT(*) FROM notification_history 
            WHERE sent_at >= date('now', '-7 days')
        ''')
        notifications_last_week = cursor.fetchone()[0]
        
        conn.close()
        
        return {
            'active_subscriptions': active_subscriptions,
            'unique_users': unique_users,
            'frequency_distribution': frequency_stats,
            'notifications_last_week': notifications_last_week,
            'last_updated': datetime.now().isoformat()
        }

# Int√©gration avec le syst√®me d'analyse de sentiment
class NewsSubscriptionService:
    def __init__(self, analyzer, subscription_manager):
        """
        Service combin√© d'analyse et d'abonnements
        
        Args:
            analyzer: Instance de NewsSentimentAnalyzer
            subscription_manager: Instance de KeywordSubscriptionManager
        """
        self.analyzer = analyzer
        self.subscription_manager = subscription_manager
        self.running = False
        
    def start_monitoring(self, check_interval_minutes: int = 60):
        """
        D√©marre la surveillance automatique
        
        Args:
            check_interval_minutes (int): Intervalle de v√©rification en minutes
        """
        def monitor_loop():
            while self.running:
                try:
                    logger.info("üîç V√©rification des nouvelles actualit√©s...")
                    
                    # Analyser les actualit√©s
                    df_news = self.analyzer.process_news_batch(
                        query="actualit√©s france",
                        language="fr",
                        use_rss=True
                    )
                    
                    if not df_news.empty:
                        # Convertir en liste de dictionnaires
                        articles = df_news.to_dict('records')
                        
                        # Traiter les abonnements
                        self.subscription_manager.process_subscriptions(articles)
                        
                        # Nettoyer l'historique si n√©cessaire
                        if datetime.now().hour == 2:  # Nettoyage quotidien √† 2h
                            self.subscription_manager.cleanup_old_notifications()
                    
                except Exception as e:
                    logger.error(f"Erreur dans la boucle de surveillance: {e}")
                
                # Attendre avant la prochaine v√©rification
                time.sleep(check_interval_minutes * 60)
        
        self.running = True
        monitor_thread = threading.Thread(target=monitor_loop, daemon=True)
        monitor_thread.start()
        logger.info(f"Surveillance d√©marr√©e (intervalle: {check_interval_minutes} minutes)")
    
    def stop_monitoring(self):
        """Arr√™te la surveillance"""
        self.running = False
        logger.info("Surveillance arr√™t√©e")

# Exemple d'utilisation
if __name__ == "__main__":
    # Importer l'analyseur de sentiment (du code pr√©c√©dent)
    from news_sentiment_analyzer import NewsSentimentAnalyzer
    
    # Initialiser les composants
    analyzer = NewsSentimentAnalyzer()
    subscription_manager = KeywordSubscriptionManager()
    
    # Configurer l'email (optionnel)
    # subscription_manager.configure_email(
    #     smtp_server="smtp.gmail.com",
    #     port=587,
    #     username="votre_email@gmail.com",
    #     password="votre_app_password",
    #     from_email="votre_email@gmail.com"
    # )
    
    # Cr√©er quelques abonnements d'exemple
    print("üìù Cr√©ation d'abonnements d'exemple...")
    
    # Abonnement 1: Politique avec sentiment positif
    sub1_id = subscription_manager.create_subscription(
        user_email="user1@example.com",
        keywords=["politique", "√©lections", "gouvernement"],
        sentiment_filter="positive",
        frequency="daily",
        min_confidence=0.3
    )
    
    # Abonnement 2: √âconomie tous sentiments
    sub2_id = subscription_manager.create_subscription(
        user_email="user2@example.com",
        keywords=["√©conomie", "inflation", "croissance", "bourse"],
        frequency="hourly",
        min_confidence=0.5
    )
    
    # Abonnement 3: Tech avec wildcards
    sub3_id = subscription_manager.create_subscription(
        user_email="user3@example.com",
        keywords=["intelligence artificielle", "IA", "*tech*", "startup*"],
        sentiment_filter="positive",
        frequency="real_time",
        sources_filter=["Le Figaro", "Les Echos"]
    )
    
    print(f"‚úÖ Cr√©√© {3} abonnements d'exemple")
    
    # Afficher les statistiques
    stats = subscription_manager.get_subscription_stats()
    print(f"\nüìä Statistiques:")
    print(f"- Abonnements actifs: {stats['active_subscriptions']}")
    print(f"- Utilisateurs uniques: {stats['unique_users']}")
    print(f"- R√©partition par fr√©quence: {stats['frequency_distribution']}")
    
    # Test avec des articles
    print("\nüß™ Test avec des articles...")
    df_news = analyzer.process_news_batch(use_rss=True)
    
    if not df_news.empty:
        articles = df_news.to_dict('records')
        subscription_manager.process_subscriptions(articles)
        print("‚úÖ Traitement des abonnements termin√©")
    
    # D√©marrer la surveillance (optionnel)
    # service = NewsSubscriptionService(analyzer, subscription_manager)
    # service.start_monitoring(check_interval_minutes=30)
    # print("üöÄ Surveillance d√©marr√©e")